package ned.tools;

import java.util.Arrays;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;

import ned.types.Utility;

public class HyperPlansManager {
	private int hyperplanes;
	private int dimension;
	
	private int dimension_jumps;
	double[] data ;
	int length;
	private Callable<Boolean>  futureTask;
	private Future<?> locker;

	public HyperPlansManager(int hyperplanes, int dimension, int dimension_jumps)
	{
		this.dimension = dimension;
		this.dimension_jumps = dimension_jumps;
		this.hyperplanes = hyperplanes;
		length = hyperplanes * dimension;
		data = new double[length];
	}
	
	public void init()
	{
		fill(0);
	}
	
	public void fill(int startIndex)
	{
		for(int i=startIndex; i<data.length; i++)
			data[i] = Utility.randomFill();
	}


//	private void fixDimWait(int j) {
//		while(j>=dimension)
//			//wait
//		{
//			try {
//				Thread.sleep(1);
//				fixDim(j);
//			} catch (InterruptedException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//		}
//	}

	public void fixDim(int newdim)
	{
		prepare();
		
		if(newdim < dimension)
			return;
		
		try {
			
			try {
				locker.get();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
			
			length = data.length;
			dimension = length/hyperplanes;
			futureTask = null;
			
		} catch (InterruptedException e) {
			
			e.printStackTrace();
		
		}
			
		prepare();
	}
	
	private void prepare()
	{
		if (futureTask != null)
			return;
		
		synchronized (this) {			
			if (futureTask != null)
				return;

			futureTask = () -> {
				int newlength = length + hyperplanes * dimension_jumps;
				
				data = Arrays.copyOf(data, newlength);
				fill(length);
	
				//System.out.println("data is ready...");
				return true;
			};
			
			locker = (Future<?>)ExecutionHelper.asyncAwaitRun(futureTask);
		}
	}
	
	public double get(int i, int j)
	{
		if (i>=this.hyperplanes || i<0)
			throw new ArrayIndexOutOfBoundsException("Bad i in :(" + i + ", " + j + "). Dim: " + dimension);
		if (j>=dimension) //dimension
		{
			//System.out.println("Fixing dimension...");
			fixDim(j);
		}
		else if(j<0)
			throw new ArrayIndexOutOfBoundsException("Bad j in :(" + i + ", " + j + "). Dim: " + dimension);
		
		return data[j*hyperplanes + i];
	}

	public int getDimension()
	{
		return dimension;
	}
}
